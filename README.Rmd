---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```



(This is a draft)



# variantCallingFromIsoSeq

<!-- badges: start -->
<!-- badges: end -->

Use ground-truth VCF files generated from short-read data to compare and validate VCF files generated from different variant callers on Iso-Seq data.

## Installation

To install it use `devtools::install_github("vladimirsouza/variantCallingFromIsoSeq@main")`.





## An example on how to construct a master table

We construct a master table that contains information about the variants called by the methods to be validated and the variants in the ground-truth. From this master table, we can generate plots and analyze and compare the VCF files used to construct the table.

### Introduction

Generate a new master table to compare and validate the variant calls from Iso-Seq data when using DeepVariant alone and SplitNCigarReads + DeepVariant. The ground-truth was generated by GATK pipeline on short-read DNA data.





### Input variables

```{r}
### methods to validate
# name of the methods to validate
METHOD_NAMES <- c("dv", "dv_s")
# name of the dataset used with the methods to validate
METHOD_DATASET_NAME <- "isoSeq"
# VCF files
METHOD1_VCF_FILE <- "/home/vbarbo/project_2021/datasets/gloria_data/analysis/dv_calls/noSplitBam/deepvariant_calls_pass.vcf.gz"
METHOD2_VCF_FILE <- "/home/vbarbo/project_2021/datasets/gloria_data/analysis/dv_calls/deepvariant_calls_pass.vcf.gz"
# BAM of the data
METHOD_BAM_FILE <- "/home/vbarbo/project_2021/datasets/gloria_data/analysis/dv_calls/aln_rg_dedupped.bam"


### ground-truth
# name
TRUTH_NAME <- "tr_dna_merged"
# name of the dataset used to generate the ground-truth
TRUTH_DATASET_NAME <- "shortRead"
# VCF file
TRUTH_VCF_FILE <- "/home/vbarbo/project_2021/datasets/gloria_data/analysis/truth_merged_bams/merged.recal_exons_pass.vcf.gz"
# BAM of the data
TRUTH_BAM_FILE <- "/home/vbarbo/project_2021/datasets/gloria_data/analysis/truth_merged_bams/merged.bam"


### variables
MAX_DIST_FROM_SPLICE_SITE <- 20
THREADS <- 40
```





### libraries

```{r}
library(variantCallingFromIsoSeq)
library(GenomicAlignments)
library(dplyr)
```





### Create the master table

#### Initiate the master table

Get variant positions and which method could call them.

```{r, message=FALSE}
dat <- initiate_master_table(
  METHOD1_VCF_FILE, 
  METHOD2_VCF_FILE, 
  TRUTH_VCF_FILE,
  method_names=c(METHOD_NAMES, TRUTH_NAME)
)
```


#### get splice site positions from the BAM file

NOTE: This function may take a long time to run.

```{r, eval=FALSE}
### don't run this
splice_sites <- get_splice_sites_info(input_bam, THREADS)
```
```{r, echo=FALSE}
### load object splice_sites
load("/home/vbarbo/load_later/splice_sites.RData")
```


#### Add columns about splice sites

```{r, message=FALSE}
dat <- add_splice_site_info_to_master_table(
  dat, splice_sites,
  MAX_DIST_FROM_SPLICE_SITE
)
```


#### Add the read coverage (from the BAM file) of each variant

First, we need to load the BAM file and get the coverage with `IRanges::coverage`.

```{r, eval=FALSE}
method_bam <- readGAlignments(METHOD_BAM_FILE)
method_coverage <- coverage(method_bam)

truth_bam <- readGAlignments(TRUTH_BAM_FILE)
truth_coverage <- coverage(truth_bam)
```
```{r, echo=FALSE}
method_bam <- readGAlignments(METHOD_BAM_FILE)
### load objects `dv_u_cover` and `tr_dna_merged_cover`
load("/home/vbarbo/load_later/dv_u_cover.RData")
method_coverage <- dv_u_cover
load("/home/vbarbo/load_later/tr_dna_merged_cover.RData")
truth_coverage <- tr_dna_merged_cover
```

Add read coverage of each dataset.

```{r, message=FALSE}
dat <- add_read_coverage_from_bam_to_master_table(
  method_coverage,
  truth_coverage,
  input_table=dat,
  dataset_names=c(METHOD_DATASET_NAME, TRUTH_DATASET_NAME)
)
```


#### Add the number of N-cigar reads per site

```{r, message=FALSE}
dat <- add_number_of_n_cigar_reads_to_master_table(
  dat, 
  method_bam, 
  METHOD_DATASET_NAME
)
```


#### Add column to comprare two methods

Compare `dv` and `dv_s`. Do they call the same varaints?

```{r, message=FALSE}
dat <- add_two_method_comparison_to_master_table(
  dat, 
  METHOD_NAMES[1], 
  METHOD_NAMES[2]
)
```


#### Add column to classify method calls (compare to the ground-truth)

Classify `dv` calls.

```{r, message=FALSE}
dat <- add_method_vs_truth_comparison_to_master_table(
  dat, 
  METHOD_NAMES[1], 
  TRUTH_NAME
)
```

Classify `dv_s` calls.

```{r, message=FALSE}
dat <- add_method_vs_truth_comparison_to_master_table(
  dat, 
  METHOD_NAMES[2], 
  TRUTH_NAME
)
```





### Take a look at the master table

```{r}
head(dat)
```





### Subset and calculate the precision, sensitivity and F1-score of the methods

Take only variants in well-coverage regions in both Iso-Seq and short-read data.

```{r, message=FALSE}
well_coverage_dat <- filter(dat, 
                            isoSeq_coverage>=10 & shortRead_coverage>=40 &
                              shortRead_coverage<=70)
```

Calculate accuracy measures for `r METHOD_NAMES[1]`.

```{r}
calc_precision_sensitivity_f1Score(well_coverage_dat, METHOD_NAMES[1], TRUTH_NAME)
```

Calculate accuracy measures for `r METHOD_NAMES[2]`.

```{r}
calc_precision_sensitivity_f1Score(well_coverage_dat, METHOD_NAMES[2], TRUTH_NAME)
```


