#' Initiate master table
#'
#' This function create the first columns of the master table. Those columns indicate
#' whether a method could call of not a variant. A master table is used to get
#' information form VCF files generated from different methods and compare to
#' ground-truth VCF files.
#'
#' @param ... VCF file addresses.
#' @param method_names Vector of strings of same length of number of input VCF files.
#'
#' @return A data.frame.
#'
#' @import dplyr
#' @importFrom utils read.table
#' @importFrom stats setNames
#'
#' @export
initiate_master_table <- function(..., method_names) {
  ### load PASS variants
  vcf_file_list <- list(...)

  vcfs <- lapply(vcf_file_list, function(vcf_file) {
    vcf <- read.table(vcf_file)
    vcf[ vcf[[7]] == "PASS", ]
  })

  ### split VCFs by chromosomes
  present_chromosomes <- bind_rows(vcfs) %>%
    pull(1) %>%
    unique
  vcfs <- sapply(vcfs, function(vcf) {
    lapply(present_chromosomes, function(pchrm) {
      vcf[ vcf[,1]==pchrm, ]
    })
  })

  ### which variants are contained in each vcf and their DP tag (from VCF file)
  master_table <- apply(vcfs, 1, function(vcfs_chrmI) {
    all_positions <- bind_rows(vcfs_chrmI) %>%
      pull(2) %>%
      unique %>%
      sort
    in_chrmI_methodJ <- sapply(vcfs_chrmI, function(vcf_chrmI_methodJ) {
      1 * ( all_positions %in% vcf_chrmI_methodJ[[2]] )
    })

    dv_chrmI_methodJ <- sapply(vcfs_chrmI, function(vcf_chrmI_methodJ) {
      res <- strsplit(vcf_chrmI_methodJ[[10]], ":") %>%
        sapply("[", 3) %>%
        as.integer() %>%
        setNames(vcf_chrmI_methodJ[[2]])
      res <- unname( res[ as.character(all_positions) ] )
    })

    data.frame(chrom=vcfs_chrmI[[1]] [[1]] [1],
               pos=all_positions,
               in_chrmI_methodJ,
               dv_chrmI_methodJ)
  })
  master_table <- bind_rows(master_table)

  method_names <- c( paste0("in_", method_names),
                     paste0("dp_", method_names) )
  names(master_table)[-(1:2)] <- method_names

  master_table
}





#' Get all splice sites positions of a BAM files
#'
#' Get the position of all splice sites in a BAM file and the number of reads that
#' support each one of them. Besides that, indicate whether the splice site is
#' acceptor or donor site.
#'
#' This function may take several hours to run.
#'
#' @param input_bam The input BAM file to extract splice site positions from.
#' @param threads Number of threads.
#'
#' @return A data.frame in which each row is a splice-site position.
#'
#' @import GenomicAlignments
#' @import dplyr
#' @importFrom BiocParallel MulticoreParam bpmapply
#' @importFrom utils head
#'
#' @export
get_splice_sites_info <- function(input_bam, threads){
  ss <- extractAlignmentRangesOnReference( cigar(input_bam), start(input_bam),  )

  # add chromossome name
  chrm_name <- as.vector( seqnames(input_bam) )

  multicoreParam <- MulticoreParam(workers = threads)
  ss <- bpmapply(function(ss_i, chrm_name_i){
    if(length(ss_i) > 1){
      ss_start <- start(ss_i)[-1]
      ss_end <- head( end(ss_i), -1 )
      is_acceptor_site <- rep( c(1L:0L), c( length(ss_start), length(ss_end) ) )
      data.frame(chrm= chrm_name_i, pos= c(ss_start, ss_end),
                 is_acceptor_site)
    }else{
      NULL
    }
  }, ss, chrm_name, BPPARAM=multicoreParam)

  ss <- do.call(rbind, ss)
  if( is.null(ss) )
    return(NULL)
  ss <- group_by(ss, chrm, pos, is_acceptor_site) %>%
    tally

  ss
}






#' Add columns about spice sites the a master table
#'
#'
#'
#' @param input_table A data.frame generated by \code{initiate_master_table}.
#' @param splice_sites A data.frame generated by \code{get_splice_sites_info}.
#' @param max_dist_from_splice_site A 1-length integer that indicates the
#'   the maximum distance of a varaint from any splice site to consider it
#'   a variant near a splice site.
#'
#' @return A data.frame.
#'
#' @import GenomicAlignments
#' @import dplyr
#'
#' @export
add_splice_site_info_to_master_table <- function(input_table,
                                                 splice_sites,
                                                 max_dist_from_splice_site=20) {
  if( !(names(input_table)[1] == "chrom") ){
    stop("First column of input_table is not 'chrom'.\nAre you sure input_table was created by initiate_master_table?")
  }
  if( !(names(input_table)[2] == "pos") ){
    stop("First column of input_table is not 'pos'.\nAre you sure input_table was created by initiate_master_table?")
  }

  splice_sites_split_by_chrm <- split(splice_sites, splice_sites$chrm)
  input_table_split_by_chrm <- names(splice_sites_split_by_chrm) %>%
    lapply(., function(chrm_i) {
      table_chrmI <- input_table[ input_table$chrom==chrm_i, ]
      if( nrow(table_chrmI) > 0 ){
        table_chrmI
      }else{
        NULL
      }
    })

  table_ss_i <- mapply(function(table_i, ss_i){
    ss_ir <- IRanges(ss_i$pos, width=1) %>%
      resize( width=2*max_dist_from_splice_site+1, fix="center" )
    re_ir <- IRanges(table_i$pos, width=1)
    ovl <- findOverlaps(re_ir, ss_ir)
    table_i$near_ss <- integer( nrow(table_i) )
    table_i$near_ss[ queryHits(ovl) ] <- 1L

    ss_lines <- split( subjectHits(ovl), queryHits(ovl) )
    re_lines <- as.integer( names(ss_lines) )

    ss_n <- ss_dist <- is_acceptor_site <- as.list( rep(NA, nrow(table_i)) )

    k <- lapply(ss_lines, function(sl){
      ss_i$n[sl]
    })
    ss_n[ re_lines ] <- k

    k <- mapply(function(rl, sl){
      table_i[rl,"pos"] - ss_i[sl,"pos", drop=T]
    }, re_lines, ss_lines, SIMPLIFY=FALSE)
    ss_dist[ table_i$near_ss == 1] <- k

    k <- mapply(function(sl){
      ss_i[sl,"is_acceptor_site", drop=T]
    }, ss_lines, SIMPLIFY=FALSE, USE.NAMES=FALSE)
    is_acceptor_site[ table_i$near_ss == 1] <- k

    table_i$ss_dist <- ss_dist
    table_i$is_acceptor_site <- is_acceptor_site
    table_i$ss_n <- ss_n

    table_i$single_ss <- 1*( lengths(table_i$is_acceptor_site) == 1 )
    table_i$single_ss[ is.na(table_i$is_acceptor_site) ] <- NA

    table_i
  }, input_table_split_by_chrm, splice_sites_split_by_chrm, SIMPLIFY=FALSE)

  table_ss_i <- do.call(rbind, table_ss_i)
  rownames(table_ss_i) <- NULL
  table_ss_i
}





