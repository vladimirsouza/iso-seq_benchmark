#' Initiate master table
#'
#' This function create the first columns of the master table. Those columns indicate
#' whether a method could call of not a variant. A master table is used to get
#' information form VCF files generated from different methods and compare to
#' ground-truth VCF files.
#'
#' @param ... VCF file addresses.
#' @param method_names Vector of strings in which each element is the identification
#'   (name) of each input VCF files. The order of these elements must be in accordance
#'   with the order of the input files, and its length must be the same as the number
#'   of input VCF files.
#'
#' @return A data.frame.
#'
#' @import dplyr
#' @importFrom utils read.table
#' @importFrom stats setNames
#'
#' @export
initiate_master_table <- function(..., method_names) {
  ### load PASS variants
  vcf_file_list <- list(...)

  if( length(vcf_file_list) != length(method_names) ) {
    stop("Length of method_names must be the same as the number of input VCF files.")
  }

  vcfs <- lapply(vcf_file_list, function(vcf_file) {
    vcf <- read.table(vcf_file)
    vcf[ vcf[[7]] == "PASS", ]
  })

  ### split VCFs by chromosomes
  present_chromosomes <- bind_rows(vcfs) %>%
    pull(1) %>%
    unique
  vcfs <- sapply(vcfs, function(vcf) {
    lapply(present_chromosomes, function(pchrm) {
      vcf[ vcf[,1]==pchrm, ]
    })
  })

  ### which variants are contained in each vcf and their DP tag (from VCF file)
  master_table <- apply(vcfs, 1, function(vcfs_chrmI) {
    all_positions <- bind_rows(vcfs_chrmI) %>%
      pull(2) %>%
      unique %>%
      sort
    in_chrmI_methodJ <- sapply(vcfs_chrmI, function(vcf_chrmI_methodJ) {
      1 * ( all_positions %in% vcf_chrmI_methodJ[[2]] )
    })

    dv_chrmI_methodJ <- sapply(vcfs_chrmI, function(vcf_chrmI_methodJ) {
      res <- strsplit(vcf_chrmI_methodJ[[10]], ":") %>%
        sapply("[", 3) %>%
        as.integer() %>%
        setNames(vcf_chrmI_methodJ[[2]])
      res <- unname( res[ as.character(all_positions) ] )
    })

    data.frame(chrm=vcfs_chrmI[[1]] [[1]] [1],
               pos=all_positions,
               in_chrmI_methodJ,
               dv_chrmI_methodJ)
  })
  master_table <- bind_rows(master_table)

  method_names <- c( paste0("in_", method_names),
                     paste0("dp_", method_names) )
  names(master_table)[-(1:2)] <- method_names

  master_table
}





#' Get all splice sites positions of a BAM files
#'
#' Get the position of all splice sites in a BAM file and the number of reads that
#' support each one of them. Besides that, indicate whether the splice site is
#' acceptor or donor site.
#'
#' This function may take several hours to run.
#'
#' @param input_bam The input BAM file to extract splice site positions from.
#' @param threads Number of threads.
#'
#' @return A data.frame in which each row is a splice-site position.
#'
#' @import GenomicAlignments
#' @import dplyr
#' @importFrom BiocParallel MulticoreParam bpmapply
#' @importFrom utils head
#'
#' @export
get_splice_sites_info <- function(input_bam, threads){
  ss <- extractAlignmentRangesOnReference( cigar(input_bam), start(input_bam),  )

  # add chromossome name
  chrm_name <- as.vector( seqnames(input_bam) )

  multicoreParam <- MulticoreParam(workers = threads)
  ss <- bpmapply(function(ss_i, chrm_name_i){
    if(length(ss_i) > 1){
      ss_start <- start(ss_i)[-1]
      ss_end <- head( end(ss_i), -1 )
      is_acceptor_site <- rep( c(1L:0L), c( length(ss_start), length(ss_end) ) )
      data.frame(chrm= chrm_name_i, pos= c(ss_start, ss_end),
                 is_acceptor_site)
    }else{
      NULL
    }
  }, ss, chrm_name, BPPARAM=multicoreParam)

  ss <- do.call(rbind, ss)
  if( is.null(ss) )
    return(NULL)
  ss <- group_by(ss, chrm, pos, is_acceptor_site) %>%
    tally

  ss
}






#' Add columns about spice sites to a master table
#'
#'
#'
#' @param input_table A data.frame generated by \code{initiate_master_table}.
#' @param splice_sites A data.frame generated by \code{get_splice_sites_info}.
#' @param max_dist_from_splice_site A 1-length integer that indicates the
#'   the maximum distance of a varaint from any splice site to consider it
#'   a variant near a splice site.
#'
#' @return A data.frame.
#'
#' @importFrom IRanges IRanges
#' @importFrom IRanges resize
#' @importFrom S4Vectors queryHits
#' @importFrom S4Vectors subjectHits
#' @import dplyr
#'
#' @export
add_splice_site_info_to_master_table <- function(input_table,
                                                 splice_sites,
                                                 max_dist_from_splice_site=20) {
  if( !(names(input_table)[1] == "chrm") ){
    stop("First column of input_table is not 'chrm'.\nAre you sure input_table was created by initiate_master_table?")
  }
  if( !(names(input_table)[2] == "pos") ){
    stop("First column of input_table is not 'pos'.\nAre you sure input_table was created by initiate_master_table?")
  }

  splice_sites_split_by_chrm <- split(splice_sites, splice_sites$chrm)
  input_table_split_by_chrm <- names(splice_sites_split_by_chrm) %>%
    lapply(., function(chrm_i) {
      table_chrmI <- input_table[ input_table$chrm==chrm_i, ]
      if( nrow(table_chrmI) > 0 ){
        table_chrmI
      }else{
        NULL
      }
    })

  table_ss_i <- mapply(function(table_i, ss_i){
    ss_ir <- IRanges(ss_i$pos, width=1) %>%
      resize( width=2*max_dist_from_splice_site+1, fix="center" )
    re_ir <- IRanges(table_i$pos, width=1)
    ovl <- findOverlaps(re_ir, ss_ir)
    table_i$is_near_ss <- integer( nrow(table_i) )
    table_i$is_near_ss[ queryHits(ovl) ] <- 1L

    ss_lines <- split( subjectHits(ovl), queryHits(ovl) )
    re_lines <- as.integer( names(ss_lines) )

    ss_num <- ss_dist <- is_acceptor_site <- as.list( rep(NA, nrow(table_i)) )

    k <- lapply(ss_lines, function(sl){
      ss_i$n[sl]
    })
    ss_num[ re_lines ] <- k

    k <- mapply(function(rl, sl){
      table_i[rl,"pos"] - ss_i[sl,"pos", drop=T]
    }, re_lines, ss_lines, SIMPLIFY=FALSE)
    ss_dist[ table_i$is_near_ss == 1] <- k

    k <- mapply(function(sl){
      ss_i[sl,"is_acceptor_site", drop=T]
    }, ss_lines, SIMPLIFY=FALSE, USE.NAMES=FALSE)
    is_acceptor_site[ table_i$is_near_ss == 1] <- k

    table_i$ss_dist <- ss_dist
    table_i$is_acceptor_site <- is_acceptor_site
    table_i$ss_num <- ss_num

    table_i$is_single_ss <- 1*( lengths(table_i$is_acceptor_site) == 1 )
    table_i$is_single_ss[ is.na(table_i$is_acceptor_site) ] <- NA

    table_i
  }, input_table_split_by_chrm, splice_sites_split_by_chrm, SIMPLIFY=FALSE)

  table_ss_i <- do.call(rbind, table_ss_i)
  rownames(table_ss_i) <- NULL
  table_ss_i
}









#' Add read coverage (taken from BAM file) of each dataset to a master table
#'
#' @param ... Objects generated by \code{IRanges::coverage} function.
#' @param input_table A master table to add read-coverage columns.
#' @param method_names Vector of strings in which each element is the identification
#'   (name) of each input object in '...'. The order of these elements must be in
#'   accordance with the order of the input objects in '...', and its length must be
#'   the same as the number of input VCF objects in '...'.
#'
#' @return A data frame.
#' @export
add_read_coverage_from_bam_to_master_table <- function(..., input_table, method_names) {
  datasets_coverage <- list(...)

  if( length(datasets_coverage) != length(method_names) ) {
    stop("Length of method_names must be the same as the number of objects in '...'.")
  }

  datasets_coverage_per_site <- sapply(datasets_coverage, function(cover_methodI) {
    table_cover_methodI <- seq_along(cover_methodI) %>%
      lapply(function(i) {
        input_table_i <- names(cover_methodI)[i] %>%
          { filter(input_table, chrm==.) }
        if( nrow(input_table_i)==0 )
          return(NULL)
        coverage_per_site <- as.vector( cover_methodI[[i]] ) [input_table_i$pos]
        cbind(input_table_i, coverage_per_site)
      })
    table_cover_methodI <- bind_rows(table_cover_methodI)
    right_join(table_cover_methodI, input_table) %>%
      pull(coverage_per_site)
  })
  colnames(datasets_coverage_per_site) <- paste0(method_names, "_coverage")

  cbind(input_table, datasets_coverage_per_site)
}




