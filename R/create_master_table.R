#' Initiate master table
#'
#' This function create the first columns of the master table. Those columns indicate
#' whether a method could call of not a variant. A master table is used to get
#' information form VCF files generated from different methods and compare to
#' ground-truth VCF files.
#'
#' @param ... VCF file addresses.
#' @param method_names Vector of strings in which each element is the identification
#'   (name) of each input VCF files. The order of these elements must be in accordance
#'   with the order of the input files, and its length must be the same as the number
#'   of input VCF files.
#'
#' @return A data.frame.
#'
#' @importFrom utils read.table
#' @importFrom stats setNames
#' @importFrom rlang .data
#' @import dplyr
#'
#' @export
initiate_master_table <- function(..., method_names) {
  ### load PASS variants
  vcf_file_list <- list(...)

  if( length(vcf_file_list) != length(method_names) ) {
    stop("Length of method_names must be the same as the number of input VCF files.")
  }

  vcfs <- lapply(vcf_file_list, function(vcf_file) {
    vcf <- read.table(vcf_file)
    vcf[ vcf[[7]] == "PASS", ]
  })

  ### split VCFs by chromosomes
  present_chromosomes <- bind_rows(vcfs) %>%
    pull(1) %>%
    unique
  vcfs <- sapply(vcfs, function(vcf) {
    lapply(present_chromosomes, function(pchrm) {
      vcf[ vcf[,1]==pchrm, ]
    })
  })

  ### which variants are contained in each vcf and their DP tag (from VCF file)
  master_table <- apply(vcfs, 1, function(vcfs_chrmI) {
    all_positions <- bind_rows(vcfs_chrmI) %>%
      pull(2) %>%
      unique %>%
      sort
    in_chrmI_methodJ <- sapply(vcfs_chrmI, function(vcf_chrmI_methodJ) {
      1 * ( all_positions %in% vcf_chrmI_methodJ[[2]] )
    })

    dv_chrmI_methodJ <- sapply(vcfs_chrmI, function(vcf_chrmI_methodJ) {
      res <- strsplit(vcf_chrmI_methodJ[[10]], ":") %>%
        sapply("[", 3) %>%
        as.integer() %>%
        setNames(vcf_chrmI_methodJ[[2]])
      res <- unname( res[ as.character(all_positions) ] )
    })

    data.frame(chrm=vcfs_chrmI[[1]] [[1]] [1],
               pos=all_positions,
               in_chrmI_methodJ,
               dv_chrmI_methodJ)
  })
  master_table <- bind_rows(master_table)

  method_names <- c( paste0("in_", method_names),
                     paste0("dp_", method_names) )
  names(master_table)[-(1:2)] <- method_names

  master_table
}





#' Get all splice sites positions of a BAM files
#'
#' Get the position of all splice sites in a BAM file and the number of reads that
#' support each one of them. Besides that, indicate whether the splice site is
#' acceptor or donor site.
#'
#' This function may take several hours to run.
#'
#' @param input_bam The input BAM file to extract splice site positions from.
#' @param threads Number of threads.
#'
#' @return A data.frame in which each row is a splice-site position.
#'
#' @importFrom GenomicAlignments extractAlignmentRangesOnReference cigar start
#'   end seqnames
#' @importFrom BiocParallel MulticoreParam bpmapply
#' @importFrom utils head
#' @importFrom rlang .data
#' @import dplyr
#'
#' @export
get_splice_sites_info <- function(input_bam, threads){
  ss <- extractAlignmentRangesOnReference( cigar(input_bam), start(input_bam),  )

  # add chromossome name
  chrm_name <- as.vector( seqnames(input_bam) )

  multicoreParam <- MulticoreParam(workers = threads)
  ss <- bpmapply(function(ss_i, chrm_name_i){
    if(length(ss_i) > 1){
      ss_start <- start(ss_i)[-1]
      ss_end <- head( end(ss_i), -1 )
      is_acceptor_site <- rep( c(1L:0L), c( length(ss_start), length(ss_end) ) )
      data.frame(chrm= chrm_name_i, pos= c(ss_start, ss_end),
                 is_acceptor_site)
    }else{
      NULL
    }
  }, ss, chrm_name, BPPARAM=multicoreParam)

  ss <- do.call(rbind, ss)
  if( is.null(ss) )
    return(NULL)
  ss <- group_by(ss, .data$chrm, .data$pos, .data$is_acceptor_site) %>%
    tally

  ss
}






#' Add columns about spice sites to a master table
#'
#'
#'
#' @param input_table A data.frame generated by \code{initiate_master_table}.
#' @param splice_sites A data.frame generated by \code{get_splice_sites_info}.
#' @param max_dist_from_splice_site A 1-length integer that indicates the
#'   the maximum distance of a varaint from any splice site to consider it
#'   a variant near a splice site.
#'
#' @return A data.frame.
#'
#' @importFrom IRanges IRanges resize
#' @importFrom GenomicAlignments findOverlaps
#' @importFrom S4Vectors queryHits subjectHits
#' @importFrom rlang .data
#' @import dplyr
#'
#' @export
add_splice_site_info_to_master_table <- function(input_table,
                                                 splice_sites,
                                                 max_dist_from_splice_site=20) {
  if( !(names(input_table)[1] == "chrm") ){
    stop("First column of input_table is not 'chrm'.\nAre you sure input_table was created by initiate_master_table?")
  }
  if( !(names(input_table)[2] == "pos") ){
    stop("First column of input_table is not 'pos'.\nAre you sure input_table was created by initiate_master_table?")
  }

  splice_sites_split_by_chrm <- split(splice_sites, splice_sites$chrm)
  input_table_split_by_chrm <- names(splice_sites_split_by_chrm) %>%
    lapply(function(chrm_i) {
      table_chrmI <- input_table[ input_table$chrm==chrm_i, ]
      if( nrow(table_chrmI) > 0 ){
        table_chrmI
      }else{
        NULL
      }
    })

  table_ss_i <- mapply(function(table_i, ss_i){
    ss_ir <- IRanges(ss_i$pos, width=1) %>%
      resize( width=2*max_dist_from_splice_site+1, fix="center" )
    re_ir <- IRanges(table_i$pos, width=1)
    ovl <- findOverlaps(re_ir, ss_ir)
    table_i$is_near_ss <- integer( nrow(table_i) )
    table_i$is_near_ss[ queryHits(ovl) ] <- 1L
    table_i$is_near_ss <- factor(table_i$is_near_ss, levels=0:1)

    ss_lines <- split( subjectHits(ovl), queryHits(ovl) )
    re_lines <- as.integer( names(ss_lines) )

    ss_num <- ss_dist <- is_acceptor_site <- as.list( rep(NA, nrow(table_i)) )

    k <- lapply(ss_lines, function(sl){
      ss_i$n[sl]
    })
    ss_num[ re_lines ] <- k

    k <- mapply(function(rl, sl){
      table_i[rl,"pos"] - ss_i[sl,"pos", drop=T]
    }, re_lines, ss_lines, SIMPLIFY=FALSE)
    ss_dist[ table_i$is_near_ss == 1] <- k

    k <- mapply(function(sl){
      ss_i[sl,"is_acceptor_site", drop=T]
    }, ss_lines, SIMPLIFY=FALSE, USE.NAMES=FALSE)
    is_acceptor_site[ table_i$is_near_ss == 1] <- k

    table_i$ss_dist <- ss_dist
    table_i$is_acceptor_site <- is_acceptor_site
    table_i$ss_num <- ss_num

    table_i$is_single_ss <- 1*( lengths(table_i$is_acceptor_site) == 1 )
    table_i$is_single_ss[ is.na(table_i$is_acceptor_site) ] <- -1
    table_i$is_single_ss <- factor( table_i$is_single_ss, levels=(-1):1 )

    table_i
  }, input_table_split_by_chrm, splice_sites_split_by_chrm, SIMPLIFY=FALSE)

  table_ss_i <- do.call(rbind, table_ss_i)
  rownames(table_ss_i) <- NULL
  table_ss_i
}









#' Add read coverage (taken from BAM file) of each dataset to a master table
#'
#' @param ... Objects generated by \code{IRanges::coverage} function.
#' @param input_table A master table to add read-coverage columns.
#' @param dataset_names Vector of strings in which each element is the identification
#'   (name) of each input object in '...'. The order of these elements must be in
#'   accordance with the order of the input objects in '...', and its length must be
#'   the same as the number of input VCF objects in '...'.
#'
#' @return A data frame.
#'
#' @importFrom rlang .data
#' @import dplyr
#'
#' @export
add_read_coverage_from_bam_to_master_table <- function(..., input_table, dataset_names) {
  datasets_coverage <- list(...)

  if( length(datasets_coverage) != length(dataset_names) ) {
    stop("Length of dataset_names must be the same as the number of objects in '...'.")
  }

  datasets_coverage_per_site <- sapply(datasets_coverage, function(cover_datasetI) {
    table_cover_datasetI <- seq_along(cover_datasetI) %>%
      lapply(function(i) {
        input_table_i <- names(cover_datasetI)[i] %>%
          { filter(input_table, .data$chrm==.data) }
        if( nrow(input_table_i)==0 )
          return(NULL)
        coverage_per_site <- as.vector( cover_datasetI[[i]] ) [input_table_i$pos]
        cbind(input_table_i, coverage_per_site)
      })
    table_cover_datasetI <- bind_rows(table_cover_datasetI)
    right_join(table_cover_datasetI, input_table) %>%
      pull(.data$coverage_per_site)
  })
  colnames(datasets_coverage_per_site) <- paste0(dataset_names, "_coverage")

  cbind(input_table, datasets_coverage_per_site)
}








#' Add the count of N-cigar reads to the master table
#'
#' This function adds a new column to a master table with the counts of
#' N-cigar reads that overlap each site.
#'
#' @param input_table A data.frame. The master table to add the new column.
#' @param input_bam A `GenomicAlignments` object from which N-cigar-read counts
#'   are got.
#' @param dataset_name A 1-length string used to set the name of the new column.
#'
#' @return A data.frame.
#'
#' @importFrom GenomicAlignments cigarRangesAlongReferenceSpace cigar findOverlaps
#' @importFrom IRanges IRanges
#' @importFrom S4Vectors queryHits
#' @importFrom rlang .data
#' @import dplyr
#'
#' @export
add_number_of_n_cigar_reads_to_master_table <- function(input_table, input_bam, dataset_name=NULL) {
  bam_split_by_chrm <- split( input_bam, seqnames(input_bam) )

  table_NCigarReadCount <- seq_along(bam_split_by_chrm) %>%
    lapply(function(i) {
      input_table_i <- names(bam_split_by_chrm)[i] %>%
        { filter(input_table, .data$chrm==.data) }
      if( nrow(input_table_i)==0 )
        return(NULL)

      Ns <- cigarRangesAlongReferenceSpace( cigar(bam_split_by_chrm[[i]]),
                                            ops="N",
                                            pos=start(bam_split_by_chrm[[i]]) )

      Ns <- unlist(Ns)
      variant_positions_ir <- IRanges(input_table_i$pos, width=1)
      ovl <- findOverlaps(variant_positions_ir, Ns)
      ovl <- table( queryHits(ovl) )
      n_cigar_read_count <- integer( nrow(input_table_i) )
      n_cigar_read_count [ as.integer(names(ovl)) ] <- as.vector(ovl)
      cbind(input_table_i, n_cigar_read_count)
    })
  table_NCigarReadCount <- bind_rows(table_NCigarReadCount) %>%
    right_join(input_table)
  column_name <- paste0(dataset_name, "_ncr_num")
  names(table_NCigarReadCount) [ncol(table_NCigarReadCount)] <- paste0(dataset_name, "_ncr_num")

  table_NCigarReadCount
}



#' Add column to compare two methods in a master table
#'
#' This function adds a column in a master table that compares two given methods.
#' The new column informs whether the variant was called only by the first method
#'   (`method1_name`), only by the second method (`method2_name`), by both
#'   methods (`"both"`), or neither of them (`"neither"`).
#'
#' @param input_table A data.frame. The master table to add the new column.
#' @param method1_name A 1-length string. The name of the first method.
#' @param method2_name A 1-length string. The name of the second method.
#'
#' @return A data.frame
#'
#' @importFrom snakecase to_lower_camel_case
#' @importFrom rlang .data
#' @import dplyr
#'
#' @export
add_two_method_comparison_to_master_table <- function(input_table, method1_name, method2_name) {
  variant_called_only_by <- data.frame(
    in_metho1=c(1,1,0,0),
    in_metho2=c(1,0,1,0),
    compare_methods=factor(c("both", method1_name, method2_name, "neither"))
  )
  compare_methods <- paste(
    "compare",
    snakecase::to_lower_camel_case(method1_name),
    snakecase::to_lower_camel_case(method2_name),
    sep="_"
  )
  method1_name_in <- paste0("in_", method1_name)
  method2_name_in <- paste0("in_", method2_name)
  names(variant_called_only_by) <- c(method1_name_in, method2_name_in, compare_methods)

  left_join(input_table, variant_called_only_by)
}
### add column classification (TP, FN, FP, <NA>) of dv calling



